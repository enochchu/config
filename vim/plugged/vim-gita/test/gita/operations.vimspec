let s:P = Import('System.Filepath')
let s:S = Import('Vim.ScriptLocal')
let s:sp = s:P.join(g:gita#test#root, 'autoload', 'gita', 'operations.vim')
let s:sv = s:S.svars(s:sp)
let s:sf = s:S.sfuncs(s:sp)

Describe gita#operations
  Before
    Init
  End

  Context [PRIVATE] s:prefer_shellescape({val})
    if !g:is_windows
      It should not enclose {val} with quotes if {val} doesn't contain spaces
        let ret = s:sf.prefer_shellescape('foobar')
        let exp = 'foobar'
        Assert Equals(ret, exp)
      End
      It should enclose {val} with single quotes if {val} contains spaces
        let ret = s:sf.prefer_shellescape('foo bar')
        let exp = "'foo bar'"
        Assert Equals(ret, exp)
      End
    elseif exists('&shellslash')
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End
      It should enclose {val} with quotes if {val} doesn't contain spaces
        let ret = s:sf.prefer_shellescape('foobar')
        let exp = 'foobar'
        Assert Equals(ret, exp)
      End
      It should enclose {val} with single quotes if {val} contains spaces and &shellslash=1
        set shellslash
        let ret = s:sf.prefer_shellescape('foo bar')
        let exp = "'foo bar'"
        Assert Equals(ret, exp)
      End
      It should enclose {val} with double quotes if {val} contains spaces and &shellslash=0
        set noshellslash
        let ret = s:sf.prefer_shellescape('foo bar')
        let exp = '"foo bar"'
        Assert Equals(ret, exp)
      End
    else
      It should enclose {val} with quotes if {val} doesn't contain spaces
        let ret = s:sf.prefer_shellescape('foobar')
        let exp = 'foobar'
        Assert Equals(ret, exp)
      End
      It should enclose {val} with double quotes if {val} contains spaces and -shellslash
        let ret = s:sf.prefer_shellescape('foo bar')
        let exp = '"foo bar"'
        Assert Equals(ret, exp)
      End
    endif
  End

  Context [PRIVATE] s:translate_option({key}, {val}, {pattern})
    Context Long format
      It should return "--key=value" for ('key', 'value', '')
        let ret = s:sf.translate_option('key', 'value', '')
        Assert Equals(ret, '--key=value')
      End
      if !g:is_windows || (exists('&shellslash') && &shellslash)
        It should return "--key='v a l u e'" for ('key', 'v a l u e', '')
          let ret = s:sf.translate_option('key', 'v a l u e', '')
          Assert Equals(ret, '--key=''v a l u e''')
        End
      else
        It should return '--key="v a l u e"' for ('key', 'v a l u e', '')
          let ret = s:sf.translate_option('key', 'v a l u e', '')
          Assert Equals(ret, '--key="v a l u e"')
        End
      endif
      It should return "--key" for ('key', 1, '')
        let ret = s:sf.translate_option('key', 1, '')
        Assert Equals(ret, '--key')
      End
      It should return "" for ('key', 0, '')
        let ret = s:sf.translate_option('key', 0, '')
        Assert Equals(ret, '')
      End
      It should return "-key-value-' for ('key', 'value', '-%k-%v-')
        let ret = s:sf.translate_option('key', 'value', '-%k-%v-')
        Assert Equals(ret, '-key-value-')
      End
      It should return "--h-e-l-l-o' for ('h_e_l_l_o', 1, '')
        let ret = s:sf.translate_option('h_e_l_l_o', 1, '')
        Assert Equals(ret, '--h-e-l-l-o')

        let ret = s:sf.translate_option('h_e_l_l_o', 1, '--%K')
        Assert Equals(ret, '--h-e-l-l-o')
      End
      It should return "--h_e_l_l_o' for ('h_e_l_l_o', 1, '--%k')
        let ret = s:sf.translate_option('h_e_l_l_o', 1, '--%k')
        Assert Equals(ret, '--h_e_l_l_o')
      End
      It should return "--key=value" for ('key', 'value', '--%K%{=}v')
        let ret = s:sf.translate_option('key', 'value', '--%K%{=}v')
        Assert Equals(ret, '--key=value')
      End
    End
    Context Short format
      It should return "-kvalue" for ('k', 'value', '')
        let ret = s:sf.translate_option('k', 'value', '')
        Assert Equals(ret, '-kvalue')
      End
      It should return "-k" for ('k', 1, '')
        let ret = s:sf.translate_option('k', 1, '')
        Assert Equals(ret, '-k')
      End
      It should return "" for ('k', 0, '')
        let ret = s:sf.translate_option('k', 0, '')
        Assert Equals(ret, '')
      End
      It should return "-kvalue" for ('k', 'value', '-%k%V')
        let ret = s:sf.translate_option('k', 'value', '-%k%V')
        Assert Equals(ret, '-kvalue')
      End
      if !g:is_windows || (exists('&shellslash') && &shellslash)
        It should return "-k'v a l u e'" for ('k', 'v a l u e', '-%k%V')
          let ret = s:sf.translate_option('k', 'v a l u e', '-%k%V')
          Assert Equals(ret, '-k''v a l u e''')
        End
      else
        It should return '-k"v a l u e"' for ('k', 'v a l u e', '-%k%V')
          let ret = s:sf.translate_option('k', 'v a l u e', '-%k%V')
          Assert Equals(ret, '-k"v a l u e"')
        End
      endif
    End
  End

  Context [PRIVATE] s:translate_options({options}, {scheme})
    It should translate options (dict) into arguments (list)
      let options = {
            \ 'foo': 1,
            \ 'bar': 0,
            \ 'hoge': 'hoge',
            \ 'f': 1,
            \ 'b': 0,
            \ 'h': 'hoge',
            \}
      let ret = s:sf.translate_options(options, {})
      Assert Equals(sort(ret), sort([
            \ '--foo',
            \ '--hoge=hoge',
            \ '-f',
            \ '-hhoge',
            \]))
    End
    It should apply specified schemes of each option
      let options = {
            \ 'foo': 1,
            \ 'bar': 0,
            \ 'hoge': 'hoge',
            \}
      let scheme = {
            \ 'foo': '---%k',
            \ 'hoge': '%v',
            \}
      let ret = s:sf.translate_options(options, scheme)
      Assert Equals(sort(ret), sort([
            \ '---foo',
            \ 'hoge',
            \]))
    End
  End

  Context [PRIVATE] s:execute({gita}, {args}, {conf})
    Before
      let git = {}
      let git._called_with = []
      let git._args = []
      let git._stdout = 'stdout'
      let git._status = 0
      function! git.exec(...) abort
        call add(self._called_with, a:000)
        return {
              \ 'args':   self._args,
              \ 'stdout': self._stdout,
              \ 'status': self._status,
              \}
      endfunction
      let gita = {
            \ 'enabled': 1,
            \ 'git': deepcopy(git)
            \}
      let C = Mock(s:sv, 'C').patch()
      call extend(C, git)
    End
    After
      call C.restore()
    End
    It should call {gita}.git.exec when {gita}.enabled == 1
      call s:sf.execute(gita, ['foo', 'bar'], {
            \ 'doautocmd': 0,
            \})
      call s:sf.execute(gita, ['bar', 'bar'], {
            \ 'doautocmd': 0,
            \})
      let called_with = gita.git._called_with
      Assert Equals(called_with, [
            \ [['foo', 'bar'], {'interactive': 0}],
            \ [['bar', 'bar'], {'interactive': 0}],
            \])
      let called_with = C._called_with
      Assert Equals(called_with, [])
    End
    It should call s:C.exec when {gita}.enabled == 0
      let gita.enabled = 0
      call s:sf.execute(gita, ['foo', 'bar'], {
            \ 'doautocmd': 0,
            \})
      call s:sf.execute(gita, ['bar', 'bar'], {
            \ 'doautocmd': 0,
            \})
      let called_with = gita.git._called_with
      Assert Equals(called_with, [])
      let called_with = C._called_with
      Assert Equals(called_with, [
            \ [['foo', 'bar'], {'interactive': 0}],
            \ [['bar', 'bar'], {'interactive': 0}],
            \])
    End
  End

  Context #exec({gita}, {name}, {options}[, {conf}])
    It should be executable
      Assert True(exists('*gita#operations#exec'))
    End
  End
End

