Describe gita#utils#anchor
  Before
    Init
    let g:gita#utils#anchor#unsuitable_bufname_pattern = '^unsuitable'
    let g:gita#utils#anchor#unsuitable_filetype_pattern = '^unsuitable'
  End

  Context #is_suitable({winnr})
    It should return 0 for a non file buffer with unsuitable bufname
      new unsuitable
      set filetype=suitable
      set buftype=nofile
      let ret = gita#utils#anchor#is_suitable(0)
      Assert False(ret)
    End

    It should return 0 for a non file buffer with unsuitable filetype
      new suitable
      set filetype=unsuitable
      set buftype=nofile
      let ret = gita#utils#anchor#is_suitable(0)
      Assert False(ret)
    End

    It should return 1 for a non file buffer without unsuitable bufname/filetype
      new suitable
      set filetype=suitable
      set buftype=nofile
      let ret = gita#utils#anchor#is_suitable(0)
      Assert True(ret)
    End

    It should return 1 for a file buffer with unsuitable bufname/filetype
      new suitable
      set filetype=suitable
      set buftype=
      let ret = gita#utils#anchor#is_suitable(0)
      Assert True(ret)
    End
  End

  Context #find_suitable([{winnr}])
    It should return a winnum of the next suitable window from the specified window
      " NOTE: the current window (suitable) will be 1
      rightbelow new unsuitable2 | set buftype=nofile
      rightbelow new unsuitable3 | set buftype=nofile
      rightbelow new suitable4   | set buftype=nofile
      rightbelow new unsuitable5 | set buftype=nofile

      let ret = [
            \ gita#utils#anchor#find_suitable(1),
            \ gita#utils#anchor#find_suitable(2),
            \ gita#utils#anchor#find_suitable(3),
            \ gita#utils#anchor#find_suitable(4),
            \ gita#utils#anchor#find_suitable(5),
            \]
      Assert Equals(ret, [1, 4, 4, 4, 1])
    End

    It should return 0 if there is no suitable window
      set buftype=nofile filetype=unsuitable
      rightbelow new unsuitable2 | set buftype=nofile
      rightbelow new unsuitable3 | set buftype=nofile
      rightbelow new unsuitable4 | set buftype=nofile
      rightbelow new unsuitable5 | set buftype=nofile

      let ret = [
            \ gita#utils#anchor#find_suitable(1),
            \ gita#utils#anchor#find_suitable(2),
            \ gita#utils#anchor#find_suitable(3),
            \ gita#utils#anchor#find_suitable(4),
            \ gita#utils#anchor#find_suitable(5),
            \]
      Assert Equals(ret, [0, 0, 0, 0, 0])
    End
  End

  Context #focus()
    It should focus a next suitable window
      set buftype=nofile filetype=unsuitable
      rightbelow new suitable2   | set buftype=nofile
      rightbelow new suitable3   | set buftype=nofile
      rightbelow new unsuitable4 | set buftype=nofile
      rightbelow new unsuitable5 | set buftype=nofile

      " Note:
      "   focus is in 'unsuitable5' now, thus the next suitable
      "   window is 'suitable2'
      call gita#utils#anchor#focus()
      Assert Equals(bufname('%'), 'suitable2')
    End

    It should focus a previous window if there is no suitable window found
      set buftype=nofile filetype=unsuitable
      rightbelow new unsuitable2 | set buftype=nofile
      rightbelow new unsuitable3 | set buftype=nofile
      rightbelow new unsuitable4 | set buftype=nofile
      rightbelow new unsuitable5 | set buftype=nofile

      " Note:
      "   focus is in 'unsuitable5' now, thus the previous
      "   window is 'unsuitable4'
      call gita#utils#anchor#focus()
      Assert Equals(bufname('%'), 'unsuitable4')
    End
  End
End
