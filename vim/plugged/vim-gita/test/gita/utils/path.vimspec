let s:P = Import('System.Filepath')
let s:S = Import('Vim.ScriptLocal')
let s:sf = s:S.sfuncs(s:P.join(
      \ g:gita#test#root, 'autoload', 'gita', 'utils', 'path.vim'
      \))

Describe gita#utils#path
  Before
    Init
  End

  Context [PRIVATE] s:ensure_abspath({path})
    It should return {path} if {path} is already an absolute path
      let abspath = s:P.join(getcwd(), 'foo.txt')
      let ret = s:sf.ensure_abspath(abspath)
      Assert Equals(ret, abspath)
      Assert Same(ret, abspath)
    End

    It should return an absolute path of {path} which exists
      let relpath = 'foo.txt'
      let ret = s:sf.ensure_abspath(relpath)
      let exp = s:P.join(getcwd(), relpath)
      Assert NotSame(ret, relpath)
      Assert NotEquals(ret, relpath)
      Assert Equals(ret, exp)
    End

    It should return an absolute path of {path} which does not exist
      let relpath = s:P.join('hoge', 'bar.txt')
      let ret = s:sf.ensure_abspath(relpath)
      Assert NotSame(ret, relpath)
      Assert NotEquals(ret, relpath)
      " the behavior of ':p' is not defined for non existing file
      " thus opposite approach is required
      Assert Equals(fnamemodify(ret, ':~:.'), relpath)
    End
  End
  Context [PRIVATE] s:ensure_relpath({path})
    It should return {path} if {path} is already a relative path
      let relpath = 'foo.txt'
      let ret = s:sf.ensure_relpath(relpath)
      Assert Equals(ret, relpath)
      Assert Same(ret, relpath)
    End

    It should return a relative path of {path}
      let abspath = s:P.join(getcwd(), 'foo.txt')
      let ret = s:sf.ensure_relpath(abspath)
      Assert NotSame(ret, abspath)
      Assert NotEquals(ret, abspath)
      Assert Equals(ret, fnamemodify(abspath, ':~:.'))
    End
  End
  Context [PRIVATE] s:ensure_unixpath({path))
    if !g:is_windows
      It should not touch {path} in non Windows OS
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = s:sf.ensure_unixpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End
    elseif exists('&shellslash')
      It should substitute backslashes in {path} to slashes in Windows (with '+shellslash' and shellslash/noshellslash)
        let saved_shellslash = &shellslash

        set shellslash
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = s:sf.ensure_unixpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:/Foo/Bar/Hoge.txt')

        set noshellslash
        let ret = s:sf.ensure_unixpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:/Foo/Bar/Hoge.txt')

        let &shellslash = saved_shellslash
      End
    else
      It should substitute backslashes in {path} to slashes in Windows (with '-shellslash')
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = s:sf.ensure_unixpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:/Foo/Bar/Hoge.txt')
      End
    endif
  End
  Context [PRIVATE] s:ensure_realpath({path))
    if !g:is_windows
      It should not touch {path} in non Windows OS
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = s:sf.ensure_realpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End
    elseif exists('&shellslash')
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End
      It should not touch {path} in Windows (with '+shellslash' and shellslash)
        set shellslash
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = s:sf.ensure_realpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End
      It should substitute slashes in {path} to backslashes in Windows (with '+shellslash' and noshellslash)
        set noshellslash
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = s:sf.ensure_realpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:\Foo\Bar\Hoge.txt')
      End
    else
      It should substitute slashes in {path} to backslashes in Windows (with '-shellslash')
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = s:sf.ensure_realpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:\Foo\Bar\Hoge.txt')
      End
    endif
  End

  Context #expand({expr})
    Before
      WorkonInside
      let bufname = 'foo.txt'
      silent execute printf('new %s', bufname)
    End

    It should return 'filename' of gita meta when '%' is specified and filename is specified
      call gita#meta#set('filename', 'foobar.txt', '%')
      let ret = gita#utils#path#expand('%')
      Assert Equals(ret, 'foobar.txt')
    End

    It should return the current buffer when '%' is specified and no filename is specified
      call gita#meta#set('filename', '', '%')
      let ret = gita#utils#path#expand('%')
      Assert Equals(ret, bufname)
    End

    It should treat filename-modifiers
      call gita#meta#set('filename', 'foobar.txt', '%')
      let ret = gita#utils#path#expand('%:r')
      Assert Equals(ret, 'foobar')

      call gita#meta#set('filename', '', '%')
      let ret = gita#utils#path#expand('%:r')
      Assert Equals(ret, fnamemodify(bufname, ':r'))
    End

  End
  Context #unix_abspath({path})
    if !g:is_windows
      It should return an expanded absolute unix path of {path} in non Windows OS
        call gita#meta#set('filename', 'foo/bar.txt', '%')
        let ret = gita#utils#path#unix_abspath('%')
        let exp = s:sf.ensure_abspath('foo/bar.txt')
        Assert Equals(ret, exp)
      End
      It should return a list of expanded absolute unix paths of {path} in non Windows OS
        call gita#meta#set('filename', 'foo/bar.txt', '%')
        let ret = gita#utils#path#unix_abspath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_abspath('foo/bar.txt'),
              \ s:sf.ensure_abspath('foo/bar.txt'),
              \ s:sf.ensure_abspath('foo/bar.txt'),
              \]
        Assert Equals(ret, exp)
      End
    elseif exists('&shellslash')
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End
      It should return an expanded absolute unix path of {path} in Windows OS (with '+shellslash')
        call gita#meta#set('filename', 'foo\bar.txt', '%')

        set shellslash
        let ret = gita#utils#path#unix_abspath('%')
        let exp = s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt'))
        Assert Equals(ret, exp)

        set noshellslash
        let ret = gita#utils#path#unix_abspath('%')
        Assert Equals(ret, exp)
      End
      It should return a list of expanded absolute unix paths of {path} in Windows OS (with '+shellslash')
        call gita#meta#set('filename', 'foo\bar.txt', '%')

        set shellslash
        let ret = gita#utils#path#unix_abspath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \]
        Assert Equals(ret, exp)

        set noshellslash
        let ret = gita#utils#path#unix_abspath(['%', '%', '%'])
        Assert Equals(ret, exp)
      End
    else
      It should return an expanded absolute unix path of {path} in Windows OS (with '-shellslash')
        call gita#meta#set('filename', 'foo\bar.txt', '%')
        let ret = gita#utils#path#unix_abspath('%')
        let exp = s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt'))
        Assert Equals(ret, exp)
      End
      It should return a list of expanded absolute unix paths of {path} in Windows OS (with '-shellslash')
        call gita#meta#set('filename', 'foo\bar.txt', '%')
        let ret = gita#utils#path#unix_abspath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \]
        Assert Equals(ret, exp)
      End
    endif
  End
  Context #unix_relpath({path})
    if !g:is_windows
      It should return an expanded relative unix path of {path} in non Windows OS
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo/bar.txt'), '%')
        let ret = gita#utils#path#unix_relpath('%')
        let exp = 'foo/bar.txt'
        Assert Equals(ret, exp)
      End
      It should return a list of expanded relative unix paths of {path} in non Windows OS
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo/bar.txt'), '%')
        let ret = gita#utils#path#unix_relpath(['%', '%', '%'])
        let exp = [
              \ 'foo/bar.txt',
              \ 'foo/bar.txt',
              \ 'foo/bar.txt',
              \]
        Assert Equals(ret, exp)
      End
    elseif exists('&shellslash')
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End
      It should return an expanded relative unix path of {path} in Windows OS (with '+shellslash')
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')

        set shellslash
        let ret = gita#utils#path#unix_relpath('%')
        let exp = s:sf.ensure_unixpath('foo\bar.txt')
        Assert Equals(ret, exp)

        set noshellslash
        let ret = gita#utils#path#unix_relpath('%')
        Assert Equals(ret, exp)
      End
      It should return a list of expanded relative unix paths of {path} in Windows OS (with '+shellslash')
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')

        set shellslash
        let ret = gita#utils#path#unix_relpath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \]
        Assert Equals(ret, exp)

        set noshellslash
        let ret = gita#utils#path#unix_relpath(['%', '%', '%'])
        Assert Equals(ret, exp)
      End
    else
      It should return an expanded relative unix path of {path} in Windows OS (with '-shellslash')
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')
        let ret = gita#utils#path#unix_relpath('%')
        let exp = s:sf.ensure_unixpath('foo\bar.txt')
        Assert Equals(ret, exp)
      End
      It should return a list of expanded relative unix paths of {path} in Windows OS (with '-shellslash')
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')
        let ret = gita#utils#path#unix_relpath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \]
        Assert Equals(ret, exp)
      End
    endif
  End
  Context #real_abspath({path})
    if !g:is_windows
      It should return an expanded absolute unix path of {path} in non Windows OS
        call gita#meta#set('filename', 'foo/bar.txt', '%')
        let ret = gita#utils#path#real_abspath('%')
        let exp = s:sf.ensure_abspath('foo/bar.txt')
        Assert Equals(ret, exp)
      End
      It should return a list of expanded absolute unix paths of {path} in non Windows OS
        call gita#meta#set('filename', 'foo/bar.txt', '%')
        let ret = gita#utils#path#real_abspath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_abspath('foo/bar.txt'),
              \ s:sf.ensure_abspath('foo/bar.txt'),
              \ s:sf.ensure_abspath('foo/bar.txt'),
              \]
        Assert Equals(ret, exp)
      End
    elseif exists('&shellslash')
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End
      It should return an expanded absolute unix path of {path} in Windows OS (with '+shellslash' and shellslash)
        call gita#meta#set('filename', 'foo\bar.txt', '%')
        set shellslash
        let ret = gita#utils#path#real_abspath('%')
        let exp = s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt'))
        Assert Equals(ret, exp)
      End
      It should return an expanded absolute windows path of {path} in Windows OS (with '+shellslash' and noshellslash)
        call gita#meta#set('filename', 'foo\bar.txt', '%')
        set noshellslash
        let ret = gita#utils#path#real_abspath('%')
        let exp = s:sf.ensure_realpath(s:sf.ensure_abspath('foo\bar.txt'))
        Assert Equals(ret, exp)
      End
      It should return a list of expanded absolute unix paths of {path} in Windows OS (with '+shellslash' and shellslash)
        call gita#meta#set('filename', 'foo\bar.txt', '%')
        set shellslash
        let ret = gita#utils#path#real_abspath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_unixpath(s:sf.ensure_abspath('foo\bar.txt')),
              \]
        Assert Equals(ret, exp)
      End
      It should return a list of expanded absolute windows paths of {path} in Windows OS (with '+shellslash' and noshellslash)
        call gita#meta#set('filename', 'foo\bar.txt', '%')
        set noshellslash
        let ret = gita#utils#path#real_abspath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_realpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_realpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_realpath(s:sf.ensure_abspath('foo\bar.txt')),
              \]
        Assert Equals(ret, exp)
      End
    else
      It should return an expanded absolute windows path of {path} in Windows OS (with '-shellslash')
        call gita#meta#set('filename', 'foo\bar.txt', '%')
        let ret = gita#utils#path#real_abspath('%')
        let exp = s:sf.ensure_realpath(s:sf.ensure_abspath('foo\bar.txt'))
        Assert Equals(ret, exp)
      End
      It should return a list of expanded absolute windows paths of {path} in Windows OS (with '-shellslash')
        call gita#meta#set('filename', 'foo\bar.txt', '%')
        let ret = gita#utils#path#real_abspath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_realpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_realpath(s:sf.ensure_abspath('foo\bar.txt')),
              \ s:sf.ensure_realpath(s:sf.ensure_abspath('foo\bar.txt')),
              \]
        Assert Equals(ret, exp)
      End
    endif
  End
  Context #real_relpath({path})
    if !g:is_windows
      It should return an expanded relative unix path of {path} in non Windows OS
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo/bar.txt'), '%')
        let ret = gita#utils#path#real_relpath('%')
        let exp = 'foo/bar.txt'
        Assert Equals(ret, exp)
      End
      It should return a list of expanded relative unix paths of {path} in non Windows OS
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo/bar.txt'), '%')
        let ret = gita#utils#path#real_relpath(['%', '%', '%'])
        let exp = [
              \ 'foo/bar.txt',
              \ 'foo/bar.txt',
              \ 'foo/bar.txt',
              \]
        Assert Equals(ret, exp)
      End
    elseif exists('&shellslash')
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End
      It should return an expanded relative unix path of {path} in Windows OS (with '+shellslash' and shellslash)
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')
        set shellslash
        let ret = gita#utils#path#real_relpath('%')
        let exp = s:sf.ensure_unixpath('foo\bar.txt')
        Assert Equals(ret, exp)
      End
      It should return an expanded relative windows path of {path} in Windows OS (with '+shellslash' and noshellslash)
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')
        set noshellslash
        let ret = gita#utils#path#real_relpath('%')
        let exp = s:sf.ensure_realpath('foo\bar.txt')
        Assert Equals(ret, exp)
      End
      It should return a list of expanded relative unix paths of {path} in Windows OS (with '+shellslash' and shellslash)
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')
        set shellslash
        let ret = gita#utils#path#real_relpath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \ s:sf.ensure_unixpath('foo\bar.txt'),
              \]
        Assert Equals(ret, exp)
      End
      It should return a list of expanded relative windows paths of {path} in Windows OS (with '+shellslash' and noshellslash)
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')
        set noshellslash
        let ret = gita#utils#path#real_relpath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_realpath('foo\bar.txt'),
              \ s:sf.ensure_realpath('foo\bar.txt'),
              \ s:sf.ensure_realpath('foo\bar.txt'),
              \]
        Assert Equals(ret, exp)
      End
    else
      It should return an expanded relative windows path of {path} in Windows OS (with '-shellslash')
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')
        let ret = gita#utils#path#real_relpath('%')
        let exp = s:sf.ensure_realpath('foo\bar.txt')
        Assert Equals(ret, exp)
      End
      It should return a list of expanded relative windows paths of {path} in Windows OS (with '-shellslash')
        call gita#meta#set('filename', s:P.join(getcwd(), 'foo\bar.txt'), '%')
        let ret = gita#utils#path#real_relpath(['%', '%', '%'])
        let exp = [
              \ s:sf.ensure_realpath('foo\bar.txt'),
              \ s:sf.ensure_realpath('foo\bar.txt'),
              \ s:sf.ensure_realpath('foo\bar.txt'),
              \]
        Assert Equals(ret, exp)
      End
    endif
  End
End
