Describe gita#utils#status
  Before
    Init
  End

  Context #virtual({path}[, {extra}])
    It should return a virtual status from a path
      let gita = gita#get()
      let ret = gita#utils#status#virtual('foo.txt')
      Assert Equals(ret, {
            \ 'path': 'foo.txt',
            \ 'index':    ' ',
            \ 'worktree': ' ',
            \ 'sign':     '  ',
            \ 'record':   '   foo.txt',
            \ 'is_conflict':  0,
            \ 'is_staged':    0,
            \ 'is_unstaged':  0,
            \ 'is_untracked': 0,
            \ 'is_ignored':   0,
            \})
    End

    It should override fields with {extra}
      let gita = gita#get()
      let ret = gita#utils#status#virtual('foo.txt', {
            \ 'index': 'M',
            \ 'worktree': 'M',
            \ 'sign': 'MM',
            \ 'record': 'MM foo.txt',
            \ 'is_staged': 1,
            \ 'is_unstaged': 1,
            \})
      Assert Equals(ret, {
            \ 'path': 'foo.txt',
            \ 'index':    'M',
            \ 'worktree': 'M',
            \ 'sign':     'MM',
            \ 'record':   'MM foo.txt',
            \ 'is_conflict':  0,
            \ 'is_staged':    1,
            \ 'is_unstaged':  1,
            \ 'is_untracked': 0,
            \ 'is_ignored':   0,
            \})
    End
  End

  Context #extend_status({status}, {gita})
    It should make 'path' absolute
      let status = gita#utils#status#virtual('foo.txt')
      let gita = gita#get()
      let ret = gita#utils#status#extend_status(status, gita)
      Assert Equals(ret.path, gita#utils#path#unix_abspath('foo.txt'))
    End

    It should make 'path2' absolute as well
      let status = gita#utils#status#virtual('foo.txt', {
            \ 'path2': 'bar.txt',
            \})
      let gita = gita#get()
      let ret = gita#utils#status#extend_status(status, gita)
      Assert Equals(ret.path, gita#utils#path#unix_abspath('foo.txt'))
      Assert Equals(ret.path2, gita#utils#path#unix_abspath('bar.txt'))
    End

    It should not extend status which has extended
      let status = gita#utils#status#virtual('foo.txt')
      let gita = gita#get()
      let ret1 = gita#utils#status#extend_status(status, gita)
      let ret2 = gita#utils#status#extend_status(ret1, gita)
      Assert NotEquals(status, ret1)
      Assert NotSame(status, ret1)
      Assert Equals(ret1, ret2)
      Assert Same(ret1, ret2)
    End

    It should extend an original status if 'inplace' is specified
      let status = gita#utils#status#virtual('foo.txt')
      let gita = gita#get()
      call gita#utils#status#extend_status(status, gita, { 'inplace': 1 })
      Assert Equals(status.path, gita#utils#path#unix_abspath('foo.txt'))
    End
  End

  Context #parse(stdout[, {config}])
    It should parse git status --porcelain stdout
      let stdout = join([
            \ 'M  foo.txt',
            \ ' M bar.txt',
            \ 'MM hoge.txt',
            \], "\n")
      let ret = gita#utils#status#parse(stdout)
      Assert Equals(len(ret.all), 3)
      Assert Equals(len(ret.staged), 2)
      Assert Equals(len(ret.unstaged), 2)

      Assert Equals(ret.all[0].path, gita#utils#path#unix_abspath('foo.txt'))
      Assert Equals(ret.all[1].path, gita#utils#path#unix_abspath('bar.txt'))
      Assert Equals(ret.all[2].path, gita#utils#path#unix_abspath('hoge.txt'))

      Assert Equals(ret.staged[0].path, gita#utils#path#unix_abspath('foo.txt'))
      Assert Equals(ret.staged[1].path, gita#utils#path#unix_abspath('hoge.txt'))

      Assert Equals(ret.unstaged[0].path, gita#utils#path#unix_abspath('bar.txt'))
      Assert Equals(ret.unstaged[1].path, gita#utils#path#unix_abspath('hoge.txt'))
    End

    It should parse git status --porcelain stdout as 'fail_silently'
      let stdout = join([
            \ 'warning: LF will be replaced by CRLF in vimrc.',
            \ 'M  foo.txt',
            \ ' M bar.txt',
            \ 'MM hoge.txt',
            \], "\n")
      let ret = gita#utils#status#parse(stdout)
      Assert Equals(len(ret.all), 3)
      Assert Equals(len(ret.staged), 2)
      Assert Equals(len(ret.unstaged), 2)

      Assert Equals(ret.all[0].path, gita#utils#path#unix_abspath('foo.txt'))
      Assert Equals(ret.all[1].path, gita#utils#path#unix_abspath('bar.txt'))
      Assert Equals(ret.all[2].path, gita#utils#path#unix_abspath('hoge.txt'))

      Assert Equals(ret.staged[0].path, gita#utils#path#unix_abspath('foo.txt'))
      Assert Equals(ret.staged[1].path, gita#utils#path#unix_abspath('hoge.txt'))

      Assert Equals(ret.unstaged[0].path, gita#utils#path#unix_abspath('bar.txt'))
      Assert Equals(ret.unstaged[1].path, gita#utils#path#unix_abspath('hoge.txt'))
    End
  End

  Context #retrieve({path}[, {config}])
    Before
      let gita = gita#get()
      let gita.git.cache.repository.clear()
      function! gita.operations.status(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   'M  foo.txt',
              \ ], "\n"),
              \}
      endfunction
    End

    It should retrieve a real status from {path}
      let ret = gita#utils#status#retrieve('foo.txt')
      Assert Equals(ret.path, gita#utils#path#unix_abspath('foo.txt'))
      Assert Equals(ret.index, 'M')
      Assert Equals(ret.worktree, ' ')
      Assert Equals(ret.is_staged, 1)
      Assert Equals(ret.is_unstaged, 0)
    End
  End

  Context #extend_candidate({candidate}[, {status}])
    Before
      let gita = gita#get()
      let gita.git.cache.repository.clear()
      function! gita.operations.status(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   'M  foo.txt',
              \ ], "\n"),
              \}
      endfunction
    End

    It should extend {candidate} with {status}
      let status = { 'foo': 'bar' }
      let candidate = { 'path': 'foo.txt' }
      call gita#utils#status#extend_candidate(candidate, status)
      Assert KeyExists(candidate, 'path')
      Assert KeyExists(candidate, 'status')
      Assert KeyNotExists(candidate, 'realpath')
      Assert Equals(candidate.status, status)
    End

    It should extend 'realpath' to {candidate} with {status} if it has 'path2'
      let status = { 'foo': 'bar', 'path2': 'bar.txt' }
      let candidate = { 'path': 'foo.txt' }
      call gita#utils#status#extend_candidate(candidate, status)
      Assert KeyExists(candidate, 'path')
      Assert KeyExists(candidate, 'status')
      Assert KeyExists(candidate, 'realpath')
      Assert Equals(candidate.status, status)
      Assert Equals(candidate.realpath, 'bar.txt')
    End

    It should extend {candidate} with {candidate}.{status}
      let status = { 'foo': 'bar' }
      let candidate = { 'path': 'foo.txt', 'status': status }
      call gita#utils#status#extend_candidate(candidate)
      Assert KeyExists(candidate, 'path')
      Assert KeyExists(candidate, 'status')
      Assert KeyNotExists(candidate, 'realpath')
      Assert Equals(candidate.status, status)
    End

    It should extend 'realpath' to {candidate} with {candidate}.{status} if it has 'path2'
      let status = { 'foo': 'bar', 'path2': 'bar.txt' }
      let candidate = { 'path': 'foo.txt', 'status': status }
      call gita#utils#status#extend_candidate(candidate)
      Assert KeyExists(candidate, 'path')
      Assert KeyExists(candidate, 'status')
      Assert KeyExists(candidate, 'realpath')
      Assert Equals(candidate.status, status)
      Assert Equals(candidate.realpath, 'bar.txt')
    End

    It should extend {candidate} with a retrived status
      let candidate = { 'path': 'foo.txt' }
      call gita#utils#status#extend_candidate(candidate)
      Assert KeyExists(candidate, 'path')
      Assert KeyExists(candidate, 'status')
      Assert KeyNotExists(candidate, 'realpath')
      Assert Equals(candidate.status.record, 'M  foo.txt')
    End
  End
End
