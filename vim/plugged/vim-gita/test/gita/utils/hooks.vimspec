Describe gita#utils#hooks
  Before
    Init
  End

  Context #new()
    It should return a new instance of hooks
      let ret1 = gita#utils#hooks#new()
      let ret2 = gita#utils#hooks#new()
      Assert KeyExists(ret1, 'call')
      Assert KeyExists(ret2, 'call')
      Assert NotSame(ret1, ret2)
    End
  End

  Context #get()
    It should return a singleton instance of hooks
      let ret1 = gita#utils#hooks#get()
      let ret2 = gita#utils#hooks#get()
      Assert KeyExists(ret1, 'call')
      Assert KeyExists(ret2, 'call')
      Assert Same(ret1, ret2)
    End
  End

  Context #call({name}[, ...])
    It should call 'call' method of hooks instance
      let hooks = gita#utils#hooks#get()
      function! hooks.call(name, ...) abort
        let self._call_called_with = [a:name, a:000]
      endfunction

      call gita#utils#hooks#call('foo', 'bar', 'hoge')
      Assert Equals(hooks._call_called_with, [
            \ 'foo', ['bar', 'hoge'],
            \])
    End
  End

  Context #register({name}, {fn})
    It should register {fn} as {name}
      let hooks = gita#utils#hooks#get()
      let Fn = function('gita#utils#hooks#register')
      call gita#utils#hooks#register('foo', Fn)
      Assert Equals(hooks.foo, Fn)
      Assert Same(hooks.foo, Fn)
    End
  End

  Context Instance
    Context .call({name}[, ...])
      It should call {name} method in the instance
        let hooks = gita#utils#hooks#get()
        function! hooks.foo(...) abort
          let self._foo_called_with = a:000
        endfunction

        call hooks.call('foo', 'bar', 'hoge')
        Assert Equals(hooks._foo_called_with, [
              \ 'bar', 'hoge',
              \])
      End

      It should NOT call {name} method in the instance if missing
        let hooks = gita#utils#hooks#get()

        " the following should not do anything
        call hooks.call('foo', 'bar', 'hoge')
      End
    End
  End
End
