Describe gita#utils#completes
  Before
    Init
  End

  Context #complete_branch({arglead}, {cmdline}, {cursorpos}[, ...])
    Before
      let gita = gita#get()
      function! gita.operations.branch(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   '  branch1',
              \   '  branch2',
              \   '  branch3',
              \   '* master',
              \   '  remotes/origin/HEAD -> origin/master',
              \   '  remotes/origin/branch1',
              \   '  remotes/origin/branch2',
              \   '  remotes/origin/branch3',
              \   '  remotes/origin/master',
              \ ], "\n"),
              \}
      endfunction
    End

    It should return remote branch candidates
      let ret = gita#utils#completes#complete_branch('', '', [])
      Assert Equals(ret, [
            \ 'branch1',
            \ 'branch2',
            \ 'branch3',
            \ 'master',
            \ 'origin/HEAD',
            \ 'origin/branch1',
            \ 'origin/branch2',
            \ 'origin/branch3',
            \ 'origin/master',
            \])
    End

    It should filter candidates via {arglead}
      let ret = gita#utils#completes#complete_branch('origin/bra', '', [])
      Assert Equals(ret, [
            \ 'origin/branch1',
            \ 'origin/branch2',
            \ 'origin/branch3',
            \])
    End
  End

  Context #complete_local_branch({arglead}, {cmdline}, {cursorpos}[, ...])
    Before
      let gita = gita#get()
      function! gita.operations.branch(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   '  branch1',
              \   '  branch2',
              \   '  branch3',
              \   '* master',
              \ ], "\n"),
              \}
      endfunction
    End

    It should return local branch candidates
      let ret = gita#utils#completes#complete_local_branch('', '', [])
      Assert Equals(ret, [
            \ 'branch1', 'branch2', 'branch3', 'master',
            \])
    End

    It should filter candidates via {arglead}
      let ret = gita#utils#completes#complete_local_branch('bra', '', [])
      Assert Equals(ret, [
            \ 'branch1', 'branch2', 'branch3',
            \])
    End
  End

  Context #complete_remote_branch({arglead}, {cmdline}, {cursorpos}[, ...])
    Before
      let gita = gita#get()
      function! gita.operations.branch(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   '  branch1',
              \   '  branch2',
              \   '  branch3',
              \   '* master',
              \   '  remotes/origin/HEAD -> origin/master',
              \   '  remotes/origin/branch1',
              \   '  remotes/origin/branch2',
              \   '  remotes/origin/branch3',
              \   '  remotes/origin/master',
              \ ], "\n"),
              \}
      endfunction
    End

    It should return remote branch candidates
      let ret = gita#utils#completes#complete_remote_branch('', '', [])
      Assert Equals(ret, [
            \ 'origin/HEAD',
            \ 'origin/branch1',
            \ 'origin/branch2',
            \ 'origin/branch3',
            \ 'origin/master',
            \])
    End

    It should filter candidates via {arglead}
      let ret = gita#utils#completes#complete_remote_branch('origin/bra', '', [])
      Assert Equals(ret, [
            \ 'origin/branch1',
            \ 'origin/branch2',
            \ 'origin/branch3',
            \])
    End
  End

  Context #complete_staged_files({arglead}, {cmdline}, {cursorpos}[, ...])
    Before
      let gita = gita#get()
      let gita.git.cache.repository.clear()
      function! gita.operations.status(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   'M  1staged',
              \   'M  2staged',
              \   ' M 1unstaged',
              \   ' M 2unstaged',
              \   'MM 1staged_unstaged',
              \   'MM 2staged_unstaged',
              \   'UU 1conflict',
              \   'UU 2conflict',
              \   '?? 1untracked',
              \   '?? 2untracked',
              \ ], "\n"),
              \}
      endfunction
    End

    It should return staged candidates
      let ret = gita#utils#completes#complete_staged_files('', '', [])
      Assert Equals(ret, [
            \ '1staged',
            \ '2staged',
            \ '1staged_unstaged',
            \ '2staged_unstaged',
            \])
    End

    It should filter candidates via {arglead}
      let ret = gita#utils#completes#complete_staged_files('1', '', [])
      Assert Equals(ret, [
            \ '1staged',
            \ '1staged_unstaged',
            \])
    End
  End

  Context #complete_unstaged_files({arglead}, {cmdline}, {cursorpos}[, ...])
    Before
      let gita = gita#get()
      let gita.git.cache.repository.clear()
      function! gita.operations.status(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   'M  1staged',
              \   'M  2staged',
              \   ' M 1unstaged',
              \   ' M 2unstaged',
              \   'MM 1staged_unstaged',
              \   'MM 2staged_unstaged',
              \   'UU 1conflict',
              \   'UU 2conflict',
              \   '?? 1untracked',
              \   '?? 2untracked',
              \ ], "\n"),
              \}
      endfunction
    End

    It should return unstaged candidates
      let ret = gita#utils#completes#complete_unstaged_files('', '', [])
      Assert Equals(ret, [
            \ '1unstaged',
            \ '2unstaged',
            \ '1staged_unstaged',
            \ '2staged_unstaged',
            \])
    End

    It should filter candidates via {arglead}
      let ret = gita#utils#completes#complete_unstaged_files('1', '', [])
      Assert Equals(ret, [
            \ '1unstaged',
            \ '1staged_unstaged',
            \])
    End
  End

  Context #complete_conflict_files({arglead}, {cmdline}, {cursorpos}[, ...])
    Before
      let gita = gita#get()
      let gita.git.cache.repository.clear()
      function! gita.operations.status(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   'M  1staged',
              \   'M  2staged',
              \   ' M 1unstaged',
              \   ' M 2unstaged',
              \   'MM 1staged_unstaged',
              \   'MM 2staged_unstaged',
              \   'UU 1conflict',
              \   'UU 2conflict',
              \   '?? 1untracked',
              \   '?? 2untracked',
              \ ], "\n"),
              \}
      endfunction
    End

    It should return conflicted candidates
      let ret = gita#utils#completes#complete_conflicted_files('', '', [])
      Assert Equals(ret, [
            \ '1conflict',
            \ '2conflict',
            \])
    End

    It should filter candidates via {arglead}
      let ret = gita#utils#completes#complete_conflicted_files('1', '', [])
      Assert Equals(ret, [
            \ '1conflict',
            \])
    End
  End

  Context #complete_untracked_files({arglead}, {cmdline}, {cursorpos}[, ...])
    Before
      let gita = gita#get()
      let gita.git.cache.repository.clear()
      function! gita.operations.status(...) abort
        return {
              \ 'status': 0,
              \ 'stdout': join([
              \   'M  1staged',
              \   'M  2staged',
              \   ' M 1unstaged',
              \   ' M 2unstaged',
              \   'MM 1staged_unstaged',
              \   'MM 2staged_unstaged',
              \   'UU 1conflict',
              \   'UU 2conflict',
              \   '?? 1untracked',
              \   '?? 2untracked',
              \ ], "\n"),
              \}
      endfunction
    End

    It should return untracked candidates
      let ret = gita#utils#completes#complete_untracked_files('', '', [])
      Assert Equals(ret, [
            \ '1untracked',
            \ '2untracked',
            \])
    End

    It should filter candidates via {arglead}
      let ret = gita#utils#completes#complete_untracked_files('1', '', [])
      Assert Equals(ret, [
            \ '1untracked',
            \])
    End
  End
End
