Describe gita#features
  Before
    Init
    call gita#features#_clear()
  End

  Context #is_registered({name})
    Before
      call gita#features#register(
            \ 'registered_feature',
            \ {}, {},
            \)
    End
    It should return 1 for registered {name}
      let ret = gita#features#is_registered('registered_feature')
      Assert True(ret)
    End
    It should return 0 for unregistered {name}
      let ret = gita#features#is_registered('unregistered_feature')
      Assert False(ret)
    End
  End

  Context #register({name}, {command}, {complete}[, {instance}])
    Before
      call gita#features#register(
            \ 'registered_feature',
            \ {}, {},
            \)
    End
    It should throw an exception for {name} which has already registered
      Throw gita#features#register('registered_feature', {}, {})
            \ /^vim-gita: a feature "registered_feature" has already been/
    End
    It should register {name} which has not registered
      call gita#features#register(
            \ 'unregistered_feature',
            \ {}, {},
            \)
      let ret = gita#features#is_registered('unregistered_feature')
      Assert True(ret)
    End
  End

  Context #unregister({name})
    Before
      call gita#features#register(
            \ 'registered_feature',
            \ {}, {},
            \)
    End
    It should throw an exception for {name} which has not registered yet
      Throw gita#features#unregister('unregistered_feature', {}, {})
            \ /^vim-gita: a feature "unregistered_feature" has not been/
    End
    It should unregister {name} which has registered
      call gita#features#unregister(
            \ 'registered_feature',
            \)
      let ret = gita#features#is_registered('registered_feature')
      Assert False(ret)
    End
  End

  Context #command({bang}, {range}[, {cmdline}])
    Before
      let gita = gita#get()
      let gita.operations._previous_args = []
      function! gita.operations.exec_raw(...) abort
        call add(self._previous_args, a:000)
      endfunction

      let feature = {
            \ '_previous_args': [],
            \}
      function! feature.command(...) abort
        call add(self._previous_args, a:000)
      endfunction
      function! feature.complete(...) abort
      endfunction

      call gita#features#register('known',
            \ feature.command,
            \ feature.complete,
            \ feature,
            \)
    End
    It should call raw git command if the action is not registered in features
      call gita#features#command('', [0, 0], 'unknown -a -b c')
      Assert Equals(gita.operations._previous_args, [
            \ [['unknown', '-a', '-b', 'c'], { 'interactive': 0 }]
            \])
    End
    It should call raw git command if the bang is !
      call gita#features#command('!', [0, 0], 'known -a -b c')
      Assert Equals(gita.operations._previous_args, [
            \ [['known', '-a', '-b', 'c'], { 'interactive': 0 }]
            \])
    End
    It should call gita feature if the action is registered in features
      call gita#features#command('', [0, 0], 'known -a -b c')
      Assert Equals(feature._previous_args, [
            \ ['', [0, 0], '-a -b c']
            \])
    End
  End

  Context #complete({arglead}, {cmdline}, {cursorpos})
    Before
      let feature = {
            \ '_previous_args': [],
            \}
      function! feature.command(...) abort
      endfunction
      function! feature.complete(...) abort
        call add(self._previous_args, a:000)
      endfunction

      call gita#features#register('known',
            \ feature.command,
            \ feature.complete,
            \ feature,
            \)
    End
    It should NOT call completion if the action is not registered in features
      call gita#features#complete('a', 'Gita unknown', [0, 0])
      Assert Equals(feature._previous_args, [])
    End
    It should NOT call completion if the bang is !
      call gita#features#complete('a', 'Gita! known', [0, 0])
      Assert Equals(feature._previous_args, [])
    End
    It should call completion of a registered feature
      " Note:
      "   Assume '|' indicate the position of the cursor, if user are
      "   inputting ':Gita known|', the word 'known' might be a part of
      "   'knownfoo' thus it should not call completion of 'known' yet in this
      "   point.
      call gita#features#complete('', 'Gita known', [0, 0])
      Assert Equals(feature._previous_args, [])

      " Now the input text become ':Gita known |'
      call gita#features#complete('', 'Gita known ', [0, 0])
      Assert Equals(feature._previous_args, [
            \ ['', 'known ', [0, 0]],
            \])

      " And then ':Gita known a|'
      call gita#features#complete('a', 'Gita known ', [0, 0])
      Assert Equals(feature._previous_args, [
            \ ['', 'known ', [0, 0]],
            \ ['a', 'known ', [0, 0]],
            \])

      " And then ':Gita known a b|'
      call gita#features#complete('b', 'Gita known a ', [0, 0])
      Assert Equals(feature._previous_args, [
            \ ['', 'known ', [0, 0]],
            \ ['a', 'known ', [0, 0]],
            \ ['b', 'known a ', [0, 0]],
            \])
    End
  End
End
