let s:P = Import('System.Filepath')
let s:S = Import('Vim.ScriptLocal')
let s:sf = s:S.sfuncs(s:P.join(
      \ g:gita#test#root, 'autoload', 'gita', 'action.vim'
      \))

function! GetCandidates(start, end, ...) abort
  return ['a', 'b', 'c', 'd', 'e'][ a:start : a:end ]
endfunction

Describe gita#action
  Before
    Init
  End

  Context [PRIVATE] s:default_get_candidates({start}, {end}[, {options}])
    It should return candidates based on the current buffer
      let ret = s:sf.default_get_candidates(0, 0)
      let exp = [{
            \ 'path': gita#utils#path#unix_abspath('%'),
            \ 'commit': '',
            \ 'line_start': 0,
            \ 'line_end': 0,
            \}]
      Assert Equals(ret, exp)
    End
  End

  Context #new_candidate({filename}, {commit}[, {extra}])
    It should return a candidate
      let ret = gita#action#new_candidate('', '')
      let exp = {
            \ 'path': gita#utils#path#unix_abspath('%'),
            \ 'commit': '',
            \}
      Assert Equals(ret, exp)
    End

    It should return a candidate with extra fields
      let ret = gita#action#new_candidate('', '', { 'foo': 'bar' })
      let exp = {
            \ 'path': gita#utils#path#unix_abspath('%'),
            \ 'commit': '',
            \ 'foo': 'bar',
            \}
      Assert Equals(ret, exp)
    End
  End

  Context #get_actions()
    It should return a singleton instance of 'actions'
      let ret1 = gita#action#get_actions()
      let ret2 = gita#action#get_actions()
      Assert KeyExists(ret1, 'help')
      Assert KeyExists(ret1, 'edit')
      Assert KeyExists(ret1, 'open')
      Assert KeyExists(ret1, 'diff')
      Assert Same(ret1, ret2)
    End
  End

  Context #extend_actions({actions})
    It should extend a singleton instance of 'actions'
      let ret1 = gita#action#get_actions()
      call gita#action#extend_actions({
            \ 'foo': 'bar',
            \})
      let ret2 = gita#action#get_actions()
      Assert KeyNotExists(ret1, 'foo')
      Assert KeyExists(ret2, 'foo')
      Assert NotEquals(ret1, ret2)
    End
  End

  Context #get_candidates([{start}, {end}])
    It should return candidates from s:default_get_candidates
      let ret = gita#action#get_candidates()
      let exp = [{
            \ 'path': gita#utils#path#unix_abspath('%'),
            \ 'commit': '',
            \ 'line_start': 0,
            \ 'line_end': -1,
            \}]
      Assert Equals(ret, exp)
    End

    It should return candidates from b:_gita_action_get_candidates()
      let b:_gita_action_get_candidates = function('GetCandidates')
      let ret = gita#action#get_candidates()
      Assert Equals(ret, ['a', 'b', 'c', 'd', 'e'])

      let ret = gita#action#get_candidates(2)
      Assert Equals(ret, ['c', 'd', 'e'])

      let ret = gita#action#get_candidates(2, 3)
      Assert Equals(ret, ['c', 'd'])
    End
  End

  Context #register_get_candidates({get_candidates})
    It should let b:_gita_action_get_candidates when funcref is specified
      call gita#action#register_get_candidates(function('GetCandidates'))
      let Fn = get(b:, '_gita_action_get_candidates', 0)
      Assert Equals(Fn, function('GetCandidates'))
    End
  End

  Context #smart_map(lhs, rhs)
    It should return {lhs} when the current line has a candidates
      Assert True(exists('*gita#action#smart_map'))
    End
  End

  Context #exec({name}[, {options})
    It should execute {name} action
      Assert True(exists('*gita#action#call'))
    End
  End
End
